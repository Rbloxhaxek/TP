-- Inspired by Introvert1337's teleport script :)
local util = {}
local user = game:GetService("Players").LocalPlayer
 local WAIT_SPEED = 1 / 45
 local Vehicle_Speed = 600
 local Player_Speed = 175
 local tried = {}
 local RaycastParams = RaycastParams.new()
 RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
RaycastParams.FilterDescendantsInstances = { user.Character, workspace.Vehicles, workspace:FindFirstChild("Rain")}

workspace.ChildAdded:Connect(function(child)
    if child.Name == "Rain" then 
        table.insert(RaycastParams.FilterDescendantsInstances, child)
    end
end)

user.CharacterAdded:Connect(function(character)
    table.insert(RaycastParams.FilterDescendantsInstances, character)
end)
function util:Move_To_Position(Target, Speed, Part, TeleportUp, Vehicle)
require(game:GetService("ReplicatedStorage").Tag.TagUtils).isPointInTag = newcclosure(function(a, xD)
if xD == "NoFallDamage" or xD == "NoRagdoll" or xD == "NoParachute" then
return true
end
end)
-- BTW half of this stuff was stolen off of vermillion & github but its just to look cool
 local relative_position = (Target.Position - user.Character.HumanoidRootPart.Position);
    local target_distance = relative_position.Magnitude;

    if target_distance <= 20 and not workspace:Raycast(user.Character.HumanoidRootPart.Position, relative_position.Unit * target_distance, RaycastParams) then 
        user.Character:PivotTo(Target)
        
        return;
    end; 
 local vector_position = Target.Position
 local y_level = 750
    local higher_position = Vector3.new(vector_position.X, y_level, vector_position.Z)
local SPEED_LIMITER = Speed
 local root_part = Part
 local target = Target
 local start = root_part.CFrame
 local distance = (target.p - start.p).magnitude
task.spawn(function()
if TeleportUp ~= nil then
 repeat
Part.CFrame = CFrame.new(Part.CFrame.X, y_level, Part.CFrame.Z)
root_part.Velocity = Vector3.new()

task.wait()
    until (Part.Position - higher_position).Magnitude < 15
	    Part:PivotTo(CFrame.new(Part.Position.X, vector_position.Y, Part.Position.Z))
    Part.Velocity = Vector3.zero
end
end)
 for i = 0, 1, (SPEED_LIMITER / distance) * WAIT_SPEED do
   local new_position = start:lerp(target, i)
   root_part:PivotTo(new_position)
   Part.CFrame = CFrame.new(Part.CFrame.X, y_level, Part.CFrame.Z)
root_part.Velocity = Vector3.new()
   wait(WAIT_SPEED)
 end
 Part:PivotTo(CFrame.new(Part.Position.X, vector_position.Y, Part.Position.Z))
wait(1)
require(game:GetService("ReplicatedStorage").Tag.TagUtils).isPointInTag = newcclosure(function(a, xD)
if xD == "NoFallDamage" or xD == "NoRagdoll" or xD == "NoParachute" then
return false
end
end)
end
function util:GrabVehicle(Target, Speed)
    for i,v in pairs(workspace.Vehicles:GetChildren()) do
if v.Name == "Camaro" and not workspace:Raycast(v.Seat.Position, Vector3.new(0, 750, 0), RaycastParams) and not table.find(tried, v) then
 local relative_position = (Target.Position - user.Character.HumanoidRootPart.Position);
    local target_distance = relative_position.Magnitude;
        local vehicle_distance = (v.Seat.Position - user.Character.HumanoidRootPart.Position).Magnitude;
     if target_distance < vehicle_distance then
util:Move_To_Position(Target, Player_Speed, user.Character.HumanoidRootPart, true)
return
end
util:Move_To_Position(v.Seat.CFrame, Speed, user.Character.HumanoidRootPart, true)
wait(1)
local Positions = { [1] = v.Seat.Position }

local TweenService = game:GetService("TweenService")
			
local istping = true
task.spawn(function()
	repeat
		game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
		task.wait()
	until not istping
end)
for i,v in pairs(Positions) do
	local Tween = TweenService:Create(game.Players.LocalPlayer.Character.HumanoidRootPart, TweenInfo.new((game.Players.LocalPlayer.Character.HumanoidRootPart.Position-v).Magnitude/75, Enum.EasingStyle.Linear), {CFrame = CFrame.new(v)})
	Tween:Play()
	Tween.Completed:Wait()
end
istping = false
local UI = require(game:GetService("ReplicatedStorage").Module:WaitForChild("UI"))
local EnterDriver
for x,b in pairs (UI.CircleAction.Specs) do
if b.IsVehicle and b.ShouldAllowEntry and b.Enabled and b.Name == "Enter Driver" and b.ValidRoot == v then
EnterDriver = b
end
end
local Attempts = 1
repeat
Attempts = Attempts + 1
EnterDriver:Callback(true)
wait(0.1)
until Attempts == 10 or not v:FindFirstChild("Seat") or not v.Seat:FindFirstChild('PlayerName') or v.Seat.PlayerName.Value == user.Name
if not v:FindFirstChild("Seat") or not v.Seat:FindFirstChild("PlayerName") or not v.Seat.PlayerName.Value == user.Name then
table.insert(tried, v)
 util:GrabVehicle(Target, Player_Speed)
return
else
util:Move_To_Position(Target, Vehicle_Speed, v.PrimaryPart, true)
return
end
end
end
end
local function Teleport(Target)
 if (user.Character.HumanoidRootPart.Position - Target.Position).Magnitude < 100 then
util:Move_To_Position(Target, Player_Speed, user.Character.HumanoidRootPart, true)
return
end
    if user.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then
for i,v in pairs(workspace.Vehicles:GetChildren()) do
if v:FindFirstChild("_VehicleState_"..game:GetService("Players").LocalPlayer.Name) then
util:Move_To_Position(Target, Vehicle_Speed, v.PrimaryPart, true)
return
end
end
else
util:GrabVehicle(Target, Player_Speed)
return
end
end
return Teleport
